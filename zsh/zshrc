#!/usr/bin/zsh
# login interactiveで実行される

case $OSTYPE in
linux*)
  exists_source "$HOME/.zshrc.linux"
	;;
darwin*)
  exists_source "$HOME/.zshrc.darwin"
	;;
esac


# Prompt
autoload -Uz promptinit
promptinit
setopt prompt_subst   #プロンプト定義で置き換えを使用する

#git リポジトリの状態を表示する
function rprompt-git {
  local name st color
  [[ "$PWD" =~ '/\.git(/.*)?$' ]] && return

  name=`git symbolic-ref --short HEAD 2> /dev/null`
  [[ -z $name ]] && return

  st=`git status --short 2> /dev/null`
  if [[ -n `echo "$st" | grep "^??"` ]]; then
    color=%F{yellow}
  elif [[ -n `echo "$st" | grep '^.M'` ]]; then
    color=%F{red}
  else
    color=%F{green}
  fi

  echo "[$color$name%f%b]"
}

function prompt-return-value {
  echo "%(?,,%F{red} %?%f)"
}

function prompt-ssh {
  if [[ -n "${REMOTEHOST:-}${SSH_CONNECTION:-}" ]]; then
    echo "%F{magenta}($HOST)%f"
  fi
}

export PROMPT="%B%F{cyan}%(4~|...|)%3~%b%F{white} %# %f%k"
export RPROMPT='$(prompt-return-value) $(rprompt-git)$(prompt-ssh)'

# Historyh
setopt sharehistory hist_ignore_space
setopt no_hist_reduce_blanks
setopt no_hist_ignore_all_dups  #過去の履歴と重複しても削除しない
setopt extended_history         #履歴に時刻を刻む
HISTSIZE=10000
SAVEHIST=10000
HISTFILE=~/.zsh/zsh_history

# Use emacs keybindings even if our EDITOR is set to vi
# -v にするとすごい笑える
bindkey -e

exists_source $HOME/.zsh_antigen      #after of autoload and before compinit
# Use modern completion system
autoload -U compinit

compinit
exists_source $HOME/.zsh_completion   #requrie after compinit


setopt auto_cd
setopt no_beep no_list_beep
setopt auto_list                  #補完リスト有効
setopt list_packed                #補完リストをなるべく少ない量に
setopt pushd_to_home              #pushdを引数無しで実行した時ホームに移動する
setopt interactive_comments       #コマンドラインでもコメントを使えるようにする
unsetopt transient_rprompt        #コマンド実行時にRPROMPTを
setopt auto_resume                #サスペンド中のコマンドと同じものを実行したらリジュームする
setopt extended_glob              #拡張グロッビング ~ で否定が使える
setopt always_last_prompt         #補完で行を移動しない
setopt dot_glob
setopt brace_ccl
setopt zle
setopt no_correct no_correct_all  #コマンド実行時のスペルチェック無効
setopt no_flow_control            # C-s, C-qを無効にする。
setopt clobber                    # リダイレクトで上書きする事を許可
setopt no_tify                    #バックグラウンドジョブが終了したら知らせる

zstyle ':completion:*' auto-description 'specify: %d'
zstyle ':completion:*' completer _expand _complete _correct _approximate
zstyle ':completion:*' group-name ''
zstyle ':completion:*' menu select=2
zstyle ':completion:*:default' menu select=2    #補完候補を色付けする
zstyle ':completion:*:default' list-colors ${(s.:.)LS_COLORS}
zstyle ':completion:*' list-colors ''
zstyle ':completion:*' list-prompt %SAt %p: Hit TAB for more, or the character to insert%s
zstyle ':completion:*' matcher-list '' 'm:{a-z}={A-Z}' 'm:{a-zA-Z}={A-Za-z}' 'r:|[._-]=* r:|=* l:|=*'
zstyle ':completion:*' menu select=long
zstyle ':completion:*' select-prompt %SScrolling active: current selection at %p%s
zstyle ':completion:*' use-compctl false
zstyle ':completion:*' verbose true
zstyle ':completion:*' use-cache yes

zstyle ':completion:*:*:kill:*:processes' list-colors '=(#b) #([0-9]#)*=0=01;31'
zstyle ':completion:*:kill:*' command 'ps -u $USER -o pid,%cpu,tty,cputime,cmd'


autoload -Uz edit-command-line
zle -N edit-command-line
bindkey '^xe' edit-command-line

# keymap
bindkey "^[[Z" reverse-menu-complete

exists_source $HOME/.zsh_aliases

## Functions
export BEFORE_DIR=$PWD
function precmd {
  [[ -n $BEFORE_DIR ]] && [[ $BEFORE_DIR != $PWD ]] && ls
  BEFORE_DIR=$PWD
}

function gor {
  while [ ! -f Gemfile ] && [[ $PWD != '/' ]]; do
    cd ..
  done
}

#rubyとかで作りなおしたほうがいいかも
#マッチした部分のon/off
#特定ディレクトリの無視、検索条件指定
#errorの表示 on/off
function findstr {
  if [ $# -lt 2 ];then
    echo "missing argument" 1>&2
    return 1
  fi

  local location=$1
  shift

  while [ $# -gt 1 ]; do
    local opt="$opt $1"
    shift
  done

  local str=$1

  echo "location: $location"
  echo "opt: $opt"
  echo "str: $str"

  find $location $opt -type f -exec grep -IHl "$str" {} \; 2> /dev/null
}

function mcdir {
  mkdir $@
  cd "${@:$#}"
}

function ch {
	if [ $# -eq 0 ]; then
		cd $HOME
	else
		cd $HOME/$1
	fi
}

function cr {
	if [ $# -eq 0 ]; then
		cd /
	else
		cd /$1
	fi
}

function rbenv-upgrade {
  local rbenv_dir i
  local -a plugin_dirs

  rbenv_dir=`find $HOME/ -name \.rbenv 2> /dev/null`
  if [[ -z $rbenv_dir ]]; then
    echo "rbenv not found" 1>&2
    return
  fi
  echo "enter $rbenv_dir"
  pushd $rbenv_dir > /dev/null
  echo "git pull"
  git pull

  echo "\nenter $rbenv_dir/plugins"
  cd plugins > /dev/null
  plugin_dirs=(`find ./ -name .git`)

  for i in $plugin_dirs; do
    i=`dirname $i`
    cmd="git -C $i pull"
    echo "\n$cmd"
    git -C $i pull
  done

  popd > /dev/null
}

function ermdir {
  if [[ $# -ne 1 ]]; then
    echo "operand not found" 2> /dev/null
    return 1
  fi

  rmdir -p $1/**/ 2> /dev/null
}

function binfo {
  where $1
  $1 --version
}

function colors {
  local c
  echo
  for c in {000..255}; do
    echo -n "\e[38;5;${c}m $c"
    [ $(($c%16)) -eq 15 ] && echo
  done
  echo
}

function colorsv {
  local c
  echo
  for c in {016..255}; do
    echo -n "\e[38;5;${c}m $c"
    [ $(($((c-16))%6)) -eq 5 ] && echo
  done
  echo
}

function dcho { eval "echo \$$1" }

function sln {
  local sour targ
  if [[ $# < 2 ]]; then
    echo "usage: sln source target"
    return 1
  else
    sour=`realpath -s $1`
    targ=`realpath -s $2`
    ln -svi $sour $targ
  fi
}

function binln { sln $1 $HOME/bin/${1%.*} }

function wcjp { grep -v "#" $1 | wc -m }

function there_pull {
  for i in `ls -F | grep '/$'`; do
    echo -ne "$i\t"
    git -C $i pull
  done
}

# load temproray config
exists_source $HOME/.zsh_tmp
