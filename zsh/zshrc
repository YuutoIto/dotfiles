#!/bin/zsh
# login interactiveで実行される

case $OSTYPE in
linux*)
  exists_source "$HOME/.zshrc.linux"
	;;
darwin*)
  exists_source "$HOME/.zshrc.darwin"
	;;
esac

umask 077

# Prompt
autoload -Uz promptinit
promptinit
setopt prompt_subst   #プロンプト定義で置き換えを使用する

#git リポジトリの状態を表示する
function rprompt-git {
  local name st color brace ahead behind stash
  [[ "$PWD" =~ '/\.git(/.*)?$' ]] && return

  name=`git symbolic-ref --short HEAD 2> /dev/null`
  [[ -z $name ]] && return

  st=`git status --short --branch`
  brace=`echo $st head -1 | grep -oe "\[.*]$"`
  ahead=`echo $st | grep -oe "ahead [0-9]*" | awk '{print $2}'`
  behind=`echo $st | grep -oe "behind [0-9]*" | awk '{print $2}'`
  stash=`git stash list | wc -l | grep -v "^\s*0$"`
  [[ -n $ahead ]] && ahead=" $ahead"
  [[ -n $behind ]] && behind=" $behind"
  [[ -n $stash ]] && stash=" $stash"

  st=`echo $st | sed -e 1d`
  if [[ -z $st ]]; then
    color=%F{green}
  elif [[ -n `echo "$st" | grep "^??"` ]]; then
    color=%F{yellow}
  elif [[ -n `echo "$st" | grep '^.M'` ]]; then
    color=%F{red}
  else
    color=%F{red}
  fi

  echo "[$color$name%f%b%F{green}$ahead%f%F{red}$behind%f%F{yellow}$stash%f]"
}

function prompt-return-value {
  echo "%(?,,%F{red} %?%f)"
}

function prompt-ssh {
  if [[ -n "${REMOTEHOST:-}${SSH_CONNECTION:-}" ]]; then
    echo "%F{magenta}($HOST)%f"
  fi
}

export PROMPT="%B%F{cyan}%(4~|...|)%3~%b%F{white} %# %f%k"
export RPROMPT='$(prompt-return-value) $(rprompt-git)$(prompt-ssh)'

# Historyh
setopt sharehistory hist_ignore_space
setopt no_hist_reduce_blanks
setopt no_hist_ignore_all_dups  #過去の履歴と重複しても削除しない
setopt extended_history         #履歴に時刻を刻む
HISTSIZE=10000
SAVEHIST=10000
HISTFILE=~/.zsh/zsh_history

# Use emacs keybindings even if our EDITOR is set to vi
# -v にするとすごい笑える
bindkey -e

exists_source $HOME/.zsh.antigen      #after of autoload and before compinit
# Use modern completion system
autoload -U compinit

compinit
exists_source $HOME/.zsh.completion   #requrie after compinit

DIRSTACKSIZE=100
setopt auto_pushd

setopt auto_cd
setopt no_beep no_list_beep
setopt auto_list                  #補完リスト有効
setopt list_packed                #補完リストをなるべく少ない量に
setopt pushd_to_home              #pushdを引数無しで実行した時ホームに移動する
setopt interactive_comments       #コマンドラインでもコメントを使えるようにする
unsetopt transient_rprompt        #コマンド実行時にRPROMPTを
setopt auto_resume                #サスペンド中のコマンドと同じものを実行したらリジュームする
setopt extended_glob              #拡張グロッビング ~ で否定が使える
setopt always_last_prompt         #補完で行を移動しない
setopt no_dot_glob
setopt brace_ccl
setopt zle
setopt no_correct no_correct_all  #コマンド実行時のスペルチェック無効
setopt no_flow_control            # C-s, C-qを無効にする。
setopt clobber                    # リダイレクトで上書きする事を許可
setopt no_tify                    #バックグラウンドジョブが終了したら知らせる

zstyle ':completion:*' auto-description 'specify: %d'
zstyle ':completion:*' completer _expand _complete _correct _approximate
zstyle ':completion:*' group-name ''
zstyle ':completion:*' menu select=2
zstyle ':completion:*:default' menu select=2    #補完候補を色付けする
zstyle ':completion:*:default' list-colors ${(s.:.)LS_COLORS}
zstyle ':completion:*' list-colors ''
zstyle ':completion:*' list-prompt %SAt %p: Hit TAB for more, or the character to insert%s
zstyle ':completion:*' matcher-list '' 'm:{a-z}={A-Z}' 'm:{a-zA-Z}={A-Za-z}' 'r:|[._-]=* r:|=* l:|=*'
zstyle ':completion:*' menu select=long
zstyle ':completion:*' select-prompt %SScrolling active: current selection at %p%s
zstyle ':completion:*' use-compctl false
zstyle ':completion:*' verbose true
zstyle ':completion:*' use-cache yes

zstyle ':completion:*:*:kill:*:processes' list-colors '=(#b) #([0-9]#)*=0=01;31'
zstyle ':completion:*:kill:*' command 'ps -u $USER -o pid,%cpu,tty,cputime,cmd'

# 別セッションのディレクトリに移動
# 説明表示 cddのだけはonにしてもいいかも
# zstyle ':completion:*:descriptions' format '%BCompleting%b %U%d%u'
source $HOME/.antigen/repos/*cdd.git/cdd
typeset -ga chpwd_functions
chpwd_functions+=_cdd_chpwd

autoload -Uz edit-command-line
zle -N edit-command-line
bindkey '^xe' edit-command-line

# keymap
bindkey "^[[Z" reverse-menu-complete

exists_source $HOME/.zsh.aliases

## Functions
export BEFORE_DIR=$PWD
function precmd {
  [[ -n $BEFORE_DIR ]] && [[ $BEFORE_DIR != $PWD ]] && ls
  BEFORE_DIR=$PWD
}

function gor {
  while [ ! -f Gemfile ] && [[ $PWD != '/' ]]; do
    cd ..
  done
}

#rubyとかで作りなおしたほうがいいかも
#マッチした部分のon/off
#特定ディレクトリの無視、検索条件指定
#errorの表示 on/off
function findstr {
  if [ $# -lt 2 ];then
    echo "missing argument" 1>&2
    return 1
  fi

  local location=$1
  shift

  while [ $# -gt 1 ]; do
    local opt="$opt $1"
    shift
  done

  local str=$1

  echo "location: $location"
  echo "opt: $opt"
  echo "str: $str"

  find $location $opt -type f -exec grep -IHl "$str" {} \; 2> /dev/null
}

function mcdir {
  mkdir $@
  cd "${@:$#}"
}

function ch {
	if [ $# -eq 0 ]; then
		cd $HOME
	else
		cd $HOME/$1
	fi
}

function rbenv-upgrade {
  local rbenv_dir i
  local -a plugin_dirs

  rbenv_dir=`find $HOME/ -name \.rbenv 2> /dev/null`
  if [[ -z $rbenv_dir ]]; then
    echo "rbenv not found" 1>&2
    return
  fi
  echo "enter $rbenv_dir"
  pushd $rbenv_dir > /dev/null
  echo "git pull"
  git pull

  echo "\nenter $rbenv_dir/plugins"
  cd plugins > /dev/null
  plugin_dirs=(`find ./ -name .git`)

  for i in $plugin_dirs; do
    i=`dirname $i`
    cmd="git -C $i pull"
    echo "\n$cmd"
    git -C $i pull
  done

  popd > /dev/null
}

function ermdir {
  if [[ $# -ne 1 ]]; then
    echo "operand not found" 2> /dev/null
    return 1
  fi

  rmdir -p $1/**/ 2> /dev/null
}

function binfo {
  where $1
  $1 --version
}

function colors {
  local c
  echo
  for c in {000..255}; do
    echo -n "\e[38;5;${c}m $c"
    [ $(($c%16)) -eq 15 ] && echo
  done
  echo
}

function colorsv {
  local c
  echo
  for c in {016..255}; do
    echo -n "\e[38;5;${c}m $c"
    [ $(($((c-16))%6)) -eq 5 ] && echo
  done
  echo
}

function dcho { eval "echo \$$1" }

function sln {
  local sour targ
  if [[ $# < 2 ]]; then
    echo "usage: sln source target"
    return 1
  else
    sour=`realpath -s $1`
    targ=`realpath -s $2`
    ln -svi $sour $targ
  fi
}

function binln {
  for name in $@; do
    sln $1 $HOME/bin/${name%.*}
  done
}

function wcjp { grep -v "#" $1 | wc -m }

function pull-these {
  for i in `ls -F | grep '/$'`; do
    echo -ne "$i\t"
    git -C $i pull
  done
}

function generic_rc {
  set -u
  : $1
  local dir="$1"
  shift
  case $# in
    0) vi $dir ;;
    *)
      case $1 in
        '-d' | '--dir' )  echo $dir ;;
        '-l' | '--list' ) ls $dir ;;
        '-c' | '--cd' )   cd $dir ;;
        '-g' | '--git' )  git -C $dir ${2:=sh} ;;
        * )
          if [ -e $dir/$1 ]; then
            vi $dir/$1
          else
            echo "$1 is not exists" >&2
          fi
      esac
      ;;
  esac
}

function vimrc {
  generic_rc $HOME/.vim/ $@
}

function zshrc {
  generic_rc $HOME/.dotfiles/zsh/ $@
}

function dotgit { git -C ~/.dotfiles ${1:-sh} }
function vimgit { git -C ~/.vim ${1:-sh} }

function cons-web {
if [[ $# -eq 0 ]]; then
  echo "usage: cons-web <url> <start-num> <last-num>"
  echo "       open the consecutive web pages"
  return 0
fi

  for i in {$2..$3}; do
    opera-beta $1"$i"
  done
}

# load temproray config
exists_source $HOME/.zshrc.local
