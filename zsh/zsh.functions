#!/usr/bin/env zsh -u

getuuid(){ ruby -r securerandom -e 'print SecureRandom.uuid' }
gettty(){ echo "$TTY" | sed -e 's/[^0-9]//g' }
relative(){ echo ${1:a} | sed -e "s|^$PWD/\?||" }
warn(){ echo $* >&2 }
is_num(){ expr "${1}" + 1 >&! /dev/null }

back() {
  nohup $@ >&! /dev/null <&- &!
}

autols(){
  [[ ${AUTOLS_DIR:-$PWD} != $PWD ]] && ls -F --color=always
  AUTOLS_DIR="${PWD}"
}
add-zsh-hook precmd autols

ch(){ cd $HOME/${1:-} }

mkd(){
  mkdir $@
  cd "${@:$#}"
}

rmd(){
  if [[ $# -eq 0 ]]; then
    warn "usage: ermdir <DIR> erase empty directories"
    return 1
  fi

  find ${@} -type d -empty | xargs -I{} rmdir --ignore-fail-on-non-empty -p "{}"
}

hat(){
  for i in ${@}; do
    highlight -O xterm256 "${i}"
  done
}

show-src(){
  for i in ${@}; do
    echo "---- ${i}"
    hat "${i}"
    echo
  done
}

countdown(){
  for i in {${1:-5}..1}; do
    echo -n "${i} "
    sleep 1
  done
  echo -n 0
}

ench264(){
  if (($# == 0)); then
    echo "Argument is empty." 1>&2
    return 1
  fi

  input="${1:?}"
  out="${input%.*}"
  while [[ -e $out.mp4 ]]; do
    out="${out}.new"
  done
  out="${out}.mp4"

  echo "Encode '${input}' -> '${out}'"
  ffmpeg -i "${input}" -vcodec h264 -loglevel warning "${out}"
}

vboxresize(){ VBoxManage modifymedium --resize $((1024*$1)) $2 }
title()  { echo -ne "\033]0;$1\007" }
binfo()  { which -aps $1 && $1 --version }
help()   { $1 --help 2>&1 | less }
edigo()  { vi "$1" && $2 "$1" }
xopen()  { xdg-open "${1:-.}" >/dev/null 2>&1 }
lls()    { ls -lgG --color=always  ${@-} | awk '{print $7, $8, $9}' }
dotgit() { git -C $DOT_DIR ${@:-sh} }
vimgit() { git -C ~/.vim ${@:-sh} }
md5text(){ echo -n "${1}" | md5sum | cut -f1 | cut -d \  -f 1 }
youtube-mp3(){ youtube-dl -x --audio-format mp3 "${@:-$(clip -o)}" }
youtube-ogg(){ youtube-dl -x --audio-format vorbis "${@:-$(clip -o)}" }

+r(){ chmod u+r $@ }
-r(){ chmod a-r $@ }
+w(){ chmod u+w $@ }
-w(){ chmod a-w $@ }
+x(){ chmod u+x $@ }
-x(){ chmod a-x $@ }

#color {{{
colorso(){
  local c
  echo
  for c in {000..255}; do
    echo -n "\e[38;5;${c}m $c"
    [ $(($c%16)) -eq 15 ] && echo
  done
  echo
}

colorsv(){
  local c
  echo
  for c in {016..255}; do
    echo -n "\e[38;5;${c}m $c"
    [ $(($((c-16))%6)) -eq 5 ] && echo
  done
  echo
}
# }}}

#link# {{{
sln(){
  if (($# < 2)); then
    warn "usage: sln <source> <target>"
    return 1
  else
    ln -svi ${1:a} ${2:a}
  fi
}

binln(){
  local name
  [[ ! -d $HOME/bin ]] && mkdir $HOME/bin
  for name in $@; do
    ln -svi "${name:a}" "$HOME/bin/${name:t:r}"
  done
}
# }}}

#rc commands {{{
generic_rc(){
  local dir="${1}"
  shift

  if [[ $# -eq 0 ]]; then
    "${EDITOR}" "${dir}"
    return
  fi

  case ${1} in
    '-c') cd "${dir}" ;;
    '-d') echo "${dir}" ;;
    '-l') ls "${dir}" ;;
    '-g')
      shift
      git -C "${dir}" ${@:-sh}
      ;;
    *)
      if [[ -e $dir/$1 ]]; then
        "${EDITOR}" "${dir}/${1}"
      else
        warn "${1} is not exists"
      fi
  esac
}

vimrc(){ generic_rc $HOME/.vim/ $@ }
zshrc(){ generic_rc $ZSH_DOT_DIR $@ }
# }}}

pull-these(){
  local i
  for i in */; do
    printf "%-20s" "${i}"
    git -C "${i}" pull
  done
}

host-list(){
  sudo nmap -sP "${1:-$(ip-sub)}" | sed -e "s/^\(MAC.*\)$/\1\n/"
}

cons-web(){
  if [[ $# -ne 3 ]]; then
    warn "usage: cons-web <url> <start-num> <last-num>"
    warn "       open the consecutive web pages"
    return 1
  fi

  local i
  for i in ({$2..$3}) opera-beta "$1$i"
}

dump(){
  if [[ $# -eq 0 ]]; then
    echo "usage: dump BIN [SYMBOL] [OUTPUT_FILE]" >&2
    return 1
  fi
  objdump -M intel -S "$1" | block "<.?${2:-main}.:" "^\n" | sed "/^$/d" | tee ${3:-${1%%.*}}.disa
}

# 再帰的にディレクトリのみパーミッションを変更する
dhmod(){
  ls -F | grep "/" | xargs chmod -R $@
}

#findstr # {{{
#TODO: remake.
#rubyとかで作りなおしたほうがいいかも
#マッチした部分のon/off
#特定ディレクトリの無視、検索条件指定
#errorの表示 on/off
findstr(){
  if [ $# -lt 1 ]; then
    echo "findstr [DIR] [OPTS] STR" 1>&2
    return 1
  fi

  local location str opt

  if [[ $# -eq 1 ]]; then
    location="."
  else
    location=$1
    shift
  fi

  while [ $# -gt 1 ]; do
    opt="$opt $1"
    shift
  done

  str=$1

  # echo "location: $location"
  # echo "opt: $opt"
  # echo "str: $str"

  find $location $opt -type f -exec grep -IHl "$str" {} \; 2> /dev/null
}
# }}}

#ud # {{{
ud(){
  case "${1:-}" in
    list)
      grep '^\.' ~/.cdd | sort -u -t: -k 2,2 | sed -e 's/^\.//' | sed -e 's/:/: /' | sort -n
      ;;
    '')
      dir="$(ud list | peco)"
      [[ -n $dir ]] && ud "${dir}"
      ;;
    *)
      cdd ".${1:?}"
      ;;
  esac
}

ud-add(){
  if can_exec cdd && [[ $UID -ne 0 && $PWD != $HOME ]]; then
    cdd add ".$(gettty)"
  fi
}
add-zsh-hook precmd ud-add
# }}}

#interactive filter # {{{
pc(){
  if [[ $# -eq 0 ]]; then
    warn "usage: pc command"
    return 1
  fi
  print -z $(eval $* 2>/dev/null | peco)
}

pa(){
  result=$(find ${@:-.} 2>/dev/null | peco)
  [[ -z $result ]] && return
  if [[ -d $result ]]; then
    cd "${result}"
  else
    cd "${result:h}"
  fi
}

pd(){ pa "$1" -type d }
pf(){ pa "$1" -type f }
# }}}

google_translate(){
  local arg en_jp opt

  arg=$(echo ${@} | sed -e 's/  */+/g')
  en_jp="?hl=ja&sl=en&tl=ja&ie=UTF-8&oe=UTF-8" # url
  opt="${en_jp}&text=${arg}"
  w3m "http://translate.google.com/${opt}" | block '\[\s+\]' '\[\s+\]' | tail --lines=+2
}

# improved tree
uree() {
  local s
  local -a opt
  for s in $@; do
    is_num "${s}" && opt+='-L'
    opt+="${s}"
  done
  command tree -C -l ${opt} | less -i --RAW-CONTROL-CHARS --LONG-PROMPT --chop-long-lines --quit-if-one-screen --no-init
}

enc-utf8(){
  output=$(mktemp)
  for s in $@; do
    nkf -Lu --utf8 "${s}" >! "${output}"
    mv "${output}" "${s}"
  done
}

sizes() {
  dir="${1:+$(relative $1)/}"
  ls -A "${dir:-./}" | sed "s|^|${dir}|g" | xargs -I{} du -sm '{}' 2>/dev/null | sort -n
}

lsize(){
  du -sh -- "${*:+$(relative $*)/}"*
}

rmhere() {
  if [[ -n $(ls -A) ]]; then
    warn "Here directory is not empty."
    return 1
  fi

  local dir="${PWD}"
  cd ..
  rmdir "${dir}"
}

clip(){
  local arg="${1:-}"
  if in_path xclip; then
    if [[ $arg = '-o' ]]; then
      xclip -out -selection clipboard
    elif [[ -z $arg ]]; then
      xclip -in -selection clipboard
    else
      # xclip treat "" as filename.
      xclip -in -selection clipboard "${arg}"
    fi
  elif in_path xsel; then
    if [[ $arg = '-o' ]]; then
      xsel --clipboard --output
    elif [[ -z $arg ]]; then
      xsel --clipboard --input
    else
      cat "${arg}" | xsel --clipboard --input
    fi
  else
    echo "clip: This platform not installed clipboard command(xclip/xsel)." 1>&2
    return 1
  fi
}

kill(){
  if (($# != 0)); then
    command kill $@
  else
    local -a cands
    cands=($(ps --no-headers -u "${USER}" -o pid,cmd | peco | awk '{printf("%s ", $1)}'))

    if [[ -n $cands ]]; then
      command kill $cands
    fi
  fi
}

mac-vendor(){
  if (($# != 0)); then
    curl --silent http://api.macvendors.com/$(echo "${1}" | sed -s 's/..:..:..$/00:00:00/g')
    echo
  else
    while read line; do
      mac-vendor "${line}"
    done
  fi
}

mac-arp(){
  arp -n | awk '/:/{printf("%-15s %s \n", $1, $3)}' | xargs -I {} echo "{} $(echo "{}" | awk '{print $2}' | mac-vendor)"
}
