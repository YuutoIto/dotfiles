#!/usr/bin/env zsh -eu

getuuid(){ ruby -r securerandom -e 'print SecureRandom.uuid' }
gettty(){ echo "$TTY" | sed -e 's/[^0-9]//g' }
relative(){ echo ${1:a} | sed -e "s|^$PWD/\?||" }
warn(){ echo $* >&2 }

back() {
  nohup $@ >&! /dev/null <&- &
  disown
}

export AUTOLS_DIR=$PWD
autols(){
  [[ -n $AUTOLS_DIR && $AUTOLS_DIR != $PWD ]] && ls --color=always
  AUTOLS_DIR=$PWD
}

ch(){ cd $HOME/${1:-} }

mcdir(){
  mkdir $@
  cd "${@:$#}"
}

ermdir(){
  if [[ $# -ne 1 ]]; then
    echo "usage: ermdir DIR    erase empty directories" >&2
    return 1
  fi

  rmdir -p $1/**/ 2> /dev/null
}

vboxresize(){ VBoxManage modifymedium --resize $((1024*$1)) $2 }
title()  { echo -ne "\033]0;$1\007" }
sizes()  { du -sm ./$1/* | sort -nr }
binfo()  { which -aps $1 && $1 --version }
help()   { $1 --help 2>&1 | less -SRn }
edigo()  { vi $1 && $2 $1 }
lddw()   { ldd $(which $1) }
xopen()  { xdg-open ${1:-.} }
dotgit() { git -C ~/.dotfiles ${1:-sh} }
vimgit() { git -C ~/.vim ${1:-sh} }
+r(){ chmod u+r $@ }
-r(){ chmod a-r $@ }
+w(){ chmod u+w $@ }
-w(){ chmod a-w $@ }
+x(){ chmod u+x $@ }
-x(){ chmod a-x $@ }

#color {{{
colors(){
  local c
  echo
  for c in {000..255}; do
    echo -n "\e[38;5;${c}m $c"
    [ $(($c%16)) -eq 15 ] && echo
  done
  echo
}

colorsv(){
  local c
  echo
  for c in {016..255}; do
    echo -n "\e[38;5;${c}m $c"
    [ $(($((c-16))%6)) -eq 5 ] && echo
  done
  echo
}
# }}}

#link# {{{
sln(){
  local sour targ
  if [[ $# < 2 ]]; then
    echo "usage: sln <source> <target>"
    return 1
  else
    sour=${1:a}
    targ=${2:a}
    ln -svi $sour $targ
  fi
}

binln(){
  for name in $@; do
    ln -svi ${name:a} $HOME/bin/${name:t:r}
  done
}
# }}}

#rc commands {{{
generic_rc(){
  set -ue
  local dir="$1"
  shift

  if [[ $# -eq 0 ]]; then
    $EDITOR $dir
    return $?
  fi

  case $1 in
    '-c') cd "$dir" ;;
    '-d') echo "$dir" ;;
    '-l') ls "$dir" ;;
    '-g')
      shift
      git -C "$dir" ${@:-sh}
      ;;
    * )
      if [[ -e $dir/$1 ]]; then
        $EDITOR $dir/$1
      else
        warn "$1 is not exists"
      fi
  esac
}

vimrc(){ generic_rc $HOME/.vim/ $@ }
zshrc(){ generic_rc $ZSH_DOT_DIR $@ }
# }}}

pull-these(){
  for i in `ls -F | grep '/$'`; do
    printf "%-20s" $i
    git -C $i pull
  done
}

cons-web(){
  if [[ $# -ne 3 ]]; then
    echo "usage: cons-web <url> <start-num> <last-num>"
    echo "       open the consecutive web pages"
    return 0
  fi

  for i in {$2..$3}; do
    opera-beta $1"$i"
  done
}

host-list(){
  sudo nmap -sP 192.168.1.1/24 | sed -e "s/^\(MAC.*\)$/\1 \n/"
}

dump(){
  if [[ $# -eq 0 ]]; then
    echo "usage: dump BIN [SYMBOL] [OUTPUT_FILE]" >&2
    return 1
  fi
  objdump -M intel -S "$1" | block "<.?${2:-main}.:" "^\n" | sed "/^$/d" | tee ${3:-${1%%.*}}.disa
}

# 再帰的にディレクトリのみパーミッションを変更する
dhmod(){
  ls -F | grep "/" | xargs chmod -R $1
}

#TODO: remake.
#rubyとかで作りなおしたほうがいいかも
#マッチした部分のon/off
#特定ディレクトリの無視、検索条件指定
#errorの表示 on/off
findstr(){ # {{{
  if [ $# -lt 1 ];then
    echo "findstr [DIR] [OPTS] STR" 1>&2
    return 1
  fi

  local location str opt

  if [[ $# == 1 ]];then
    location="."
  else
    location=$1
    shift
  fi

  while [ $# -gt 1 ]; do
    opt="$opt $1"
    shift
  done

  str=$1

  # echo "location: $location"
  # echo "opt: $opt"
  # echo "str: $str"

  find $location $opt -type f -exec grep -IHl "$str" {} \; 2> /dev/null
} # }}}

#ud # {{{
ud(){ cdd ".${1:?}" }
ud-add(){
  [[ $UID -ne 0 && $PWD != $HOME ]] && cdd add ".$(gettty)"
}
# }}}

#percol # {{{
pc(){
  if [[ $# -eq 0 ]]; then
    warn "usage: pc command"
    return 1
  fi
  print -z $(eval $* 2>/dev/null | percol)
}

pa(){
  result=$(find ${@:-.} 2>/dev/null | percol)
  [[ -z $result ]] && return
  if [[ -d $result ]]; then
    cd "${result}"
  else
    cd "${result:h}"
  fi
}

pd(){ pa "$1" -type d }
pf(){ pa "$1" -type f }
# }}}

google_translate(){
  local arg en_jp opt

  arg=`echo ${@} | sed -e 's/  */+/g'`
  en_jp="?hl=ja&sl=en&tl=ja&ie=UTF-8&oe=UTF-8" # url
  opt="${en_jp}&text=${arg}"
  w3m "http://translate.google.com/${opt}" | block '\[\s+\]' '\[\s+\]' | tail --lines=+2
}

pk(){
  set -ue
  out=$(pgrep "${1}")
  [[ -z $out ]] && return 1

  echo $out
  echo 'kill? (y/N)'
  read -ks key
  [[ ! $key =~ [yY] ]] && return 0

  echo 'kill: '
  pkill -c "${1}"
}
