#!/usr/bin/env zsh -u

getuuid(){ ruby -r securerandom -e 'print SecureRandom.uuid' }
gettty(){ echo "$TTY" | sed -e 's/[^0-9]//g' }
relative(){ echo "${1:a}" | sed -e "s|^${PWD}/\?||" }
warn(){ echo $* >&2 }
is_num(){ expr "${1}" + 1 >&! /dev/null }
is-elf(){ file ${1} | awk '$0=$2' | grep -q ELF }
back() { eval $@ >&! /dev/null <&- &! } # nohup?
hide(){
  out=$(mktemp --suffix=".$(date +%T).${1}.out")
  err=$(mktemp --suffix=".$(date +%T).${1}.err")

  { eval $@ > "${out}"  2> "${err}" <&-
    cat "${out}"
    cat "${err}" >&2
  } &!
}

echo-color(){
  color="${1}"
  shift
  echo -e "\e[38;5;${color}m${*}\e[00m"
}

autols(){
  [[ ${AUTOLS_DIR:-$PWD} != $PWD ]] && ls -F --color=always
  AUTOLS_DIR="${PWD}"
}
add-zsh-hook precmd autols

ch(){ cd $HOME/${1:-} }

mkd(){
  mkdir $@
  cd "${@:$#}"
}

rmd(){
  if [[ $# -eq 0 ]]; then
    warn "usage: ermdir <DIR> erase empty directories"
    return 1
  fi

  find ${@} -type d -empty | xargs -I{} rmdir --ignore-fail-on-non-empty -p "{}"
}

hat(){
  for i in ${@}; do
    source-highlight-esc.sh "${i}" 2>/dev/null || cat "${i}"
  done
}

show-src(){
  for i in ${@}; do
    echo "---- ${i}"
    hat "${i}"
    echo
  done
}


xopen(){
  for i in ${@:-.}; do
    if [[ ! -e ${i:-.} ]]; then
      warn "${i:-.} is not exists"
      return 1
    fi
    xdg-open ${i:-.} >/dev/null 2>&1
  done

}

vboxresize(){ VBoxManage modifymedium --resize $((1024*$1)) $2 }
title()  { echo -ne "\033]0;$1\007" }
binfo()  { which -aps $1 && $1 --version }
help()   { $1 --help 2>&1 | less }
edigo()  { vi "$1" && $2 "$1" }
lls()    { ls -lgG --color=always  ${@-} | awk '{print $7, $8, $9}' }
dotgit() { git -C $DOT_DIR ${@:-sh} }
vimgit() { git -C ~/.vim ${@:-sh} }
md5text(){ echo -n "${1}" | md5sum | cut -f1 | cut -d \  -f 1 }
youtube-mp3(){ youtube-dl -x --audio-format mp3 "${@:-$(clip -o)}" }
youtube-ogg(){ youtube-dl -x --audio-format vorbis "${@:-$(clip -o)}" }
sgrep(){ grep --color=auto --line-number ${@} **/* 2>/dev/null }
setuid(){ sudo chown root: "${1}" && sudo chmod u+s "${1}" }
mve(){ mv "${1}" "${1:r}.${2}" }

+r(){ chmod u+r $@ }
-r(){ chmod a-r $@ }
+w(){ chmod u+w $@ }
-w(){ chmod a-w $@ }
+x(){ chmod u+x $@ }
-x(){ chmod a-x $@ }

#link# {{{
sln(){
  if (($# < 2)); then
    warn "usage: sln <source> <target>"
    return 1
  else
    ln -svi ${1:a} ${2:a}
  fi
}

dotln(){
  local name
  mkdir -p $HOME/bin
  for name in $@; do
    ln -svi "${name:a}" "$HOME/.${name:t:r}"
  done
}

binln(){
  local name
  mkdir -p $HOME/bin
  for name in $@; do
    ln -svi "${name:a}" "$HOME/bin/${name:t:r}"
  done
}
# }}}

vimrc(){ generic_rc $HOME/.vim/ $@ }
zshrc(){ generic_rc $ZSH_DOT_DIR $@ }

set-pushurl(){
  git config remote.origin.pushurl "$(git config remote.origin.url)"
  git config remote.origin.url "$(git config remote.origin.url | tr ':' '/' | sed -e 's|^git@|https://|')"
}

host-list(){
  sudo nmap -sP "${1:-$(ip-sub | head -1)}" | sed -e "s/^\(MAC.*\)$/\1\n/"
}

dump(){
  if [[ $# -eq 0 ]]; then
    echo "usage: dump BIN [SYMBOL] [OUTPUT_FILE]" >&2
    return 1
  fi
  objdump -M intel -S "$1" | block "<.?${2:-main}.:" "^\n" | sed "/^$/d" | tee ${3:-${1%%.*}}.disa
}

# 再帰的にディレクトリのみパーミッションを変更する
dhmod(){
  ls -F | grep "/" | xargs chmod -R $@
}

#ud # {{{
ud(){
  case "${1:-}" in
    list)
      grep '^\.' ~/.cdd | sort -u -t: -k 2,2 | sed -e 's/^\.//' | sed -e 's/:/: /' | sort -n
      ;;
    '')
      dir="$(ud list | peco)"
      [[ -n $dir ]] && ud "${dir}"
      ;;
    *)
      cdd ".${1:?}"
      ;;
  esac
}

ud-add(){
  if can_exec cdd && [[ $UID -ne 0 && $PWD != $HOME ]]; then
    cdd add ".$(gettty)"
  fi
}
add-zsh-hook precmd ud-add
# }}}

#interactive filter # {{{
pc(){
  if [[ $# -eq 0 ]]; then
    warn "usage: pc command"
    return 1
  fi
  print -z $(eval $* 2>/dev/null | peco)
}

pa(){
  result=$(find ${@:-.} 2>/dev/null | peco)
  [[ -z $result ]] && return
  if [[ -d $result ]]; then
    cd "${result}"
  else
    cd "${result:h}"
  fi
}

pd(){ pa "$1" -type d }
pf(){ pa "$1" -type f }
# }}}

# improved tree
uree(){
  local s
  local -a opt
  for s in $@; do
    is_num "${s}" && opt+='-L'
    opt+="${s}"
  done
  command tree -C -l ${opt} | less -i --RAW-CONTROL-CHARS --LONG-PROMPT --chop-long-lines --quit-if-one-screen --no-init
}

sizes(){
  dir="${1:+$(relative $1)/}"
  ls -A "${dir:-./}" | sed "s|^|${dir}|g" | xargs -I{} du -sm '{}' 2>/dev/null | sort -n
}

lsize(){
  du -sh -- "${*:+$(relative $*)/}"*
}


kill(){
  if (($# != 0)); then
    command kill $@
  else
    local -a cands
    cands=($(ps --no-headers -u "${USER}" -o pid,cmd | peco | awk '{printf("%s ", $1)}'))

    if [[ -n $cands ]]; then
      command kill $cands
    fi
  fi
}

mac-vendor(){
  if (($# != 0)); then
    curl -sS http://api.macvendors.com/$(echo "${1:?Need mac address}" | sed -s 's/..:..:..$/00:00:00/g')
    echo
  else
    while read line; do
      mac-vendor "${line:?Need mac address}"
    done
  fi
}

mac-arp(){
  arp -n | awk '/:/{printf("%-15s %s\n", $1, $3)}' | while read line
  do
    echo -n "${line}   "
    mac-vendor "$(echo "${line}" | awk '$0=$2')"
  done
}

google-asm(){
  back google "${1:?opecode}" site:softwaretechnique.jp
}

gdb-disas(){
  gdb -q --batch --eval-command="disas ${2:-main}" "${1:-a.out}"
}

# trash # {{{

# Verify write permission.
# Ignore directory.
trash-safe-file(){
  if [[ -d ${name} ]]; then
    warn "cannot remove '${name}': Is a directory"
    return 0
  elif [[ -w ${1} ]]; then
    echo -n "remove write-protected file ${1}? " >&2
    if ! $(read -q); then
      return 0
    fi
  fi
  trash "${1}"
}

# ディレクトリが内包する全てのファイルの削除判定をしてまとめて消す
trash-safe-dir(){
  echo-color 31 'trash: write protected files'
  find "${1}" -type f -not -writable E
  echo-color 31 'trash: write protected dirs'
  find "${1}" -type d -not -readable -or -type d -not -writable -or -type d -not -executable E
  echo

  if $(read -q "?Remove ${1} including these files? "); then
    trash "${1}"
    echo -e '\nRemoved!'
  else
    echo
  fi
}

trash-elf(){
  for i (*); do
    is-elf "${i}" &&  trash "${i}"
  done
}
# }}}

mirrorsort(){
  sudo cp /etc/pacman.d/mirrorlist /etc/pacman.d/mirrorlist.cp
  sudo rankmirrors -m rank
}

lsmod(){
  if (($# == 0)); then
    command lsmod
  else
    command lsmod | grep -E "${*}"
  fi
}

sl(){
  sleep 0.4
  echo 'l「もしかして」'
  sleep 1.2
  echo 's「私たち」'
  sleep 1.4
  echo '「「入れ替わってる！？！？！？」」'
}

test-build(){
  : "${1:? source file}"
  "${CMD}" -O0 -m32 -fno-stack-protector -o "${1%.*}" "${1}"
}

gccs(){
  export CMD=gcc
  test-build ${@}
}

clangs(){
  export CMD=clang
  test-build ${@}
}

elf-sec(){
  objdump -d -j ."${2:-init}" --no "${1:-a.out}"
}

doko(){
  find ${2:-} -iname "*${1}*"
}

aslr(){
  sudo sysctl -w kernel.randomize_va_space=${1:-2}
}

exzip(){
  for i in ${@}; do
    unzip -d "${i:r}" "${i}"
  done
}

wgetc(){
  clip -o
  echo
  wget -O "${1:?filename}" "$(clip -o)"
}

gif-optimize(){
  convert "${1:?gif path}" -fuzz 7% -layers Optimize "${1:r}.opt.gif"
}

json_format(){
  tmpfile=`mktemp`
  cat "${1:?JSON file}" | jq . > "${tmpfile}"
  command mv "${tmpfile}" "${1}"
}


# TODO Making
tops(){
  return

  top
  htop
  nethogs
  iftop
  iotop
  atop      アクティブなプロセスのみ?
  slabtop   メモリ
  jnettop   ホストとポートごとに表示
}

stats(){ # TODO
  return

  # https://blog.riywo.com/2011/02/20/192123/
  ifstat
  netstat -taopn
  vmstat
  iostat -x
  dstat -f
  mpstat
}

docker-images-update(){
  sudo docker images | awk 'NR>1 && $0=$1' | sort -u | egrep -v '^(<none>)$' | xargs -P0 -L1 -I@ sudo docker pull @
}


autoload -Uz ruby-calc
autoload -Uz getimg
autoload -Uz enc-utf8
autoload -Uz enc264
autoload -Uz proxy-on
autoload -Uz proxy-off
autoload -Uz clip
autoload -Uz sticky-enable-gnome
autoload -Uz generic_rc
autoload -Uz cons-web
autoload -Uz pull-these
autoload -Uz countdown
autoload -Uz colorso
autoload -Uz colorsv
autoload -Uz findstr
autoload -Uz google_translate
autoload -Uz google
autoload -Uz rmhere
